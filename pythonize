#!/usr/bin/env bash
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Name:     pythonize
# Source:   https://github.com/princebot/pythonize
# Author:   prince@princebot.com
# Usage:    pythonize [--python-version PYTHON_VERSION] [--miniconda]
#                     [--packages PYTHON_PACKAGE [PYTHON_PACKAGE...]]
#                     [--wrapper APPLICATION-NAME]
# Synopsis: Download, install, and configure Python in one line.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Details:  Use pythonize to install the Anaconda Python distribution, an
#           an awesome software suite from Continuum that includes Python,
#           the conda package- and virtual-Python-environment manager, and 100+
#           useful Python packages beyond the standard library. (For a
#           lighter-weight installation, use the --miniconda option to install
#           Miniconda, which includes only Python and conda)
#
#           As an extension of its core functionality, pythonize also supports
#           easy use as a wrapper around Python programs. Invoked in wrapper
#           mode, pythonize completely abstracts Python version and library
#           dependencies from the end user of software packages: It ensures
#           your execution environment contains exactly the Python version and
#           libraries you specifiy, with no end-user expertise or end-user
#           action required.
#
#           For more information about pythonize usage, including packaging
#           your to use pythonize as a wrapper, run pythonize --help to view
#           the man page or visit https://github.com/princebot/pythonize. The
#           code is extensively commented, so you can also consult the source
#           directly to learn the implementation details.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Set program name.
declare -r PROG="pythonize"

# Set shell options
set -o pipefail
shopt -s extglob

# If the terminal believes it supports colors, use them.
COLORS_SUPPORTED=
if which tput >/dev/null; then
    if [[ -n $(tput colors) ]] && (($(tput colors) >= 8)); then
        declare -r COLORS_SUPPORTED=true
    fi
fi 2>/dev/null
if [[ -n ${COLORS_SUPPORTED} ]]; then
    # Colors
    declare -r BLACK=$(tput setaf 0)
    declare -r RED=$(tput setaf 1)
    declare -r GREEN=$(tput setaf 2)
    declare -r YELLOW=$(tput setaf 3)
    declare -r BLUE=$(tput setaf 4)
    declare -r MAGENTA=$(tput setaf 5)
    declare -r CYAN=$(tput setaf 6)
    declare -r WHITE=$(tput setaf 7)
    # Styles
    declare -r BOLD=$(tput bold)
    declare -r UL=$(tput smul)
    declare -r STOP_UL=$(tput rmul)
    declare -r CMD=$(tput setaf 7)$(tput smul)
    declare -r RESET=$(tput sgr0)
    # Cursor movement
    tput cuu1 &>/dev/null && declare -r UP_1_ROW=$(tput cuu1)
    tput cr &>/dev/null &&   declare -r TO_COL_0=$(tput cr)
    tput el &>/dev/null &&   declare -r CLR_TO_END=$(tput el)
else
    # Defensively clear these variables if colors are not supported, on the off
    # chance these have exported values.
    BLACK=
    RED=
    GREEN=
    YELLOW=
    BLUE=
    MAGENTA=
    CYAN=
    WHITE=
    BOLD=
    UL=
    STOP_UL=
    CMD=
    RESET=
    UP_1_ROW=
    TO_COL_0=
    CLR_TO_END=
fi


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#  FUNCTIONS:
#      1.  pythonize::main
#      2.  pythonize::confirm
#      3.  pythonize::create_conda_environment
#      4.  pythonize::die
#      5.  pythonize::install_anaconda
#      6.  pythonize::install_python_packages
#      7.  pythonize::run_normal_mode
#      8.  pythonize::run_wrapper_mode
#      9.  pythonize::say
#      10. pythonize::show_help
#      11. pythonize::write_shell_startup
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Parse command-line options and route to other functions.
# Globals:   Terminal-movement/terminal-color constants.
# Arguments: Command-line options.
# Functions: pythonize::die
#            pythonize::say
#            pythonize::show_help
#            pythonize::run_normal_mode
#            pythonize::run_wrapper_mode
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::main() {
    local downgrade
    local opt_mini
    local opt_wrap
    local py_vers
    local wrapper
    local -a packages
    # Parse command-line options.
    while (($# > 0)); do
        case $1 in
            help|-h|-help|--help)
                pythonize::show_help
                ;;
            -m|--miniconda)
                opt_mini=true
                shift
                ;;
            -v|--python-version)
                # Check if specified Python version is 2.6 - 2.7 or 3.3 - 3.5
                # This will need to be changed when Anaconda increments its
                # supported versions.
                if [[ $2 =~ ^(2(\.[6-7])?|3(\.[3-5])?)$ ]]; then
                    py_vers=$2
                    if [[ ! ${py_vers} =~ ^(2(\.7)?|3(\.5)?)$ ]]; then
                        # If we're not using the latest minor version of Python
                        # 2.x or 3.x, note that (see following comments in this
                        # function)
                        downgrade=true
                    fi
                    shift 2
                elif [[ $2 =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
                    pythonize::die "Unsupported Python version \"$2\""
                else
                    pythonize::say "No argument for $1 option, skipping"
                    shift
                fi
                ;;
            -p|--package?(s))
                # If we get --package instead of --packages, match anyway.
                shift
                while (($# > 0)) && [[ -n $1 && ! $1 =~ ^-.+ ]]; do
                    packages+=($1)
                    shift
                done
                ;;
            --no-op)
                # Used for testing.
                pythonize::say -a 1 -b 1 "\nNo-op mode.\n "
                exit
                ;;
            -w|--wrapper)
                if [[ -z $2 || $2 =~ ^--.+ ]]; then
                    pythonize::die "Missing argument for --wrapper option."
                fi
                opt_wrap=true
                # In wrapper mode, always install Miniconda rather than
                # Anaconda regardless of contrary command-line options.
                opt_mini=true
                wrapper=$2
                shift 2
                ;;
            *) pythonize::die "Unparsable option \"$1\"" ;;
        esac
    done
    pythonize::say -a 1 -b 1 \
        "\nStarting ${BOLD}pythonize${RESET}${GREEN} ...\n "
    local arch
    [[ $(uname -m) =~ 32 ]] && arch="x86" || arch="x86_64"
    # If we need to download Anaconda later in this script, set the type of
    # installer we'll need here: The filename we need to fetch depends on
    # whether we want Anaconda or Miniconda, Python 2.x or 3.x, x86 or x64,
    # and OS X or Linux.
    local ana_type
    [[ ${opt_mini} ]] && ana_type="Miniconda" || ana_type="Anaconda"
    [[ ${py_vers} =~ ^3 ]] && ana_type+=3
    local ana_dir=~/$(echo -n ${ana_type} | tr A-Z a-z)
    # The Anaconda installer includes the latest Python 2.x or 3.x in its
    # root (default) environment, so if we want an older version, we'll need
    # to create a new conda environment after installation.
    #
    # When that's the case, we install the ten-times smaller Miniconda package
    # for the root environment regardless of what the command-line arguments
    # specify. Then, we use conda to create a second environment with the
    # right Python version and set that as the user's default Python in
    # ~/.pythonize.startup.
    local ana_root_type
    local ana_root_dir
    if [[ ${downgrade} ]]; then
        ana_root_type=Miniconda${ana_type##*conda}
        ana_root_dir=~/$(echo -n ${ana_root_type} | tr A-Z a-z)
    fi
    if [[ ${opt_wrap} ]]; then
        pythonize::run_wrapper_mode
    else
        pythonize::run_normal_mode
    fi
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Get a yes or no from the user.
# Globals:   Terminal-movement/terminal-color constants.
# Free vars: main():
#                opt_wrap
# Arguments: None.
# Functions: pythonize::say
# Returns:   0 (yes) or 1 (no).
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::confirm() {
    local resp
    local retval=0
    # We want wrapper mode to be noninteractive, so autoconfirm everything in
    # that case.
    [[ ${opt_wrap} ]] && return ${retval}
    while read -r resp; do
        [[ ${resp} =~ ^(y|yes|n|no)$ ]] && break
        pythonize::say -b 1 "Please enter 'y' or 'n'"
    done
    [[ ${resp} =~ ^n ]] && retval=1
    return ${retval}
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Create a conda environment with the specified Python version.
# Globals:   FUNCNAME
#            Terminal-movement/terminal-color constants.
# Free vars: main():
#                py_vers
# Arguments: <conda environment>
# Functions: pythonize::die
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::create_conda_environment() {
    if [[ -z $1 ]]; then
        pythonize::die "Internal Error: No argument for ${FUNCNAME}"
    fi
    local c_env=$1
    # Check if the conda environment we want to create already exists. If it
    # does, check if we're currently using it (this can happen when rerunning a
    # pythonize-wrapped script which has previously created an environment
    # "pythonized_<program_name>" that no longer satisfies our dependencies).
    #
    # If we're currently using the target environment, switch to the root
    # environment before removing the target environment (conda cannot remove
    # an in-use environment). Otherwise, simply remove it directly.
    local e=$(conda env list \
             | awk '$2 ~ /\*/ && $3 ~ /'"${c_env}"'/ {printf $3}')
    if [[ ${e} ]]; then
        source deactivate
        source "${e%/envs*}/bin/activate" root
        conda remove -y --all -n "${c_env}"
    elif [[ $(conda env list | awk '$3 ~ /'"${c_env}"'/') ]]; then
        conda remove -y --all -n "${c_env}"
    fi
    if [[ ${opt_mini} ]]; then
        conda create -y -n "${c_env}" python=${py_vers}
    else
        conda create -y -n "${c_env}" python=${py_vers} anaconda
    fi
    if ! source activate "${c_env}"; then
        pythonize::die "Unable to access ${c_env} conda environment"
    fi
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Print formatted error messages and quit with exit code 1.
# Globals:   Terminal-movement/terminal-color constants.
# Arguments: Message string.
# Returns:   None (terminates program with exit status 1).
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::die() {
    # Rather than add external dependencies, we try to prettyprint messages
    # using shell utilties common to both BSD- and GNU-flavored *nix. We first
    # calculate the size of the columns we need; then, we shove everything
    # through echo+fold+paste to align it all while keeping the lines lengths
    # to under 79 characters.
    #
    # Colors present a special problem: "fold" counts nonprinting characters
    # when determining where to wrap columns, so it will fold colored lines
    # early depending on where nonprinting characters appear on those lines.
    #
    # Previous versions of this utility used "fmt" rather than "fold," but that
    # broke this function on OS X --- so we're using fold as the best cross-
    # alternative I currently know until I can devise a better. We just
    # manually work around the occasional prematurely wrapped line on a case-
    # by-case basis in the meantime.
    local header=" >   ${BOLD}${PROG}: Error:${RESET}${RED}"
    local char_ct=$(wc -m <(echo -n "${header}") | awk '{printf $1}')
    local inv_char_ct=$(wc -m <(echo -n "${BOLD}${RESET}${RED}") \
                        | awk '{printf $1}')
    char_ct=$((char_ct - inv_char_ct))
    local tab_ct
    if (( (char_ct % 7) == 0 || char_ct <= 15 )); then
        tab_ct=$(( (char_ct / 7) - 1 ))
    else
        tab_ct=$((char_ct / 7))
    fi
    local filler="${RESET}${RED} >"
    local i
    filler+=$'\t'
    for ((i=1; i < tab_ct && tab_ct > 0; i++)); do
        filler+=$'\t'
    done
    local line_ct
    line_ct=$(wc -l <(fold -s -w 48 <(echo -en "$@")) | awk '{printf $1}')
    header+=$'\n'
    for ((i=0; i < line_ct && line_ct >= 0; i++)); do
        header+=${filler}$'\n'
    done
    header=${header%$'\n'}
    local msg=$(paste <(echo -n "${header}") \
                      <(fold -s -w 48 <(echo -en "$@")))
    echo -e "\n${RED}${msg}${RESET}\n " >&2
    exit 1
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Install Anaconda/Miniconda.
# Globals:   FUNCNAME
#            PATH
#            Terminal-movement/terminal-color constants
# Free vars: main():
#                ana_dir
#                ana_root_type
#                ana_root_dir
#                ana_type
#                arch
#                downgrade
#                opt_mini
# Arguments: None.
# Functions: pythonize::create_conda_environment
#            pythonize::die
#            pythonize::say
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::install_anaconda() {
    # BSD mktemp works very differently from GNU mktemp and has no straight-
    # forward way to make a temporary file named the way we want --- ergo this
    # ugly, but *nix-agnostic, workaround.
    local exe=$(mktemp installer.XXXX)
    if [[ ! ${exe} ]]; then
        pythonize::die "Unable to create a unique filename via mktemp for" \
                       "downloading the Anaconda installer."
    fi
    rm -f -- "${exe}"
    exe+=".sh"
    local get_url
    local get_exe
    # Most *nixes which lack curl have wget -- and vice versa -- so try both.
    if which curl &>/dev/null; then
        get_url="curl -s"
        get_exe="curl -o ${exe}"
    elif which wget &>/dev/null; then
        get_url="wget --quiet -O -"
        get_exe="wget --quiet --show-progress -O ${exe}"
    else
        pythonize::die "Unable to find curl or wget to download ${ana_type}"
    fi
    local sys
    [[ $(uname -s) =~ [Dd]arwin ]] && sys=MacOSX || sys=Linux
    local url

    local __ana_dir
    local __ana_type
    # See comments in main() re installing versions of Python other than the
    # the latest 2.x or 3.x.
    if [[ ${downgrade} ]]; then
        __ana_dir=${ana_root_dir}
        __ana_type=${ana_root_type}
    else
        __ana_dir=${ana_dir}
        __ana_type=${ana_type}
    fi
    # The URL to download the latest Miniconda appears to be static, but the
    # URL for Anaconda seems to change whenever the version increments.
    #
    # To standardize the process for every kind of installer we may want to
    # fetch, we first search the raw HTML from Anaconda's download page and
    # grab the download link to the latest installer. Then, we try to download
    # that installer.
    trap "rm -f -- \"${exe}\"" EXIT
    if [[ ${opt_mini} || ${downgrade} ]]; then
        url=$(${get_url} http://conda.pydata.org/miniconda.html \
              | grep -Eio "https?://.*${__ana_type}.*${sys}.*${arch}\.sh" \
              | head -1)
    else
        url=$(${get_url} http://continuum.io/downloads \
              | grep -Eio "https?://.*${__ana_type}.*${sys}.*${arch}\.sh" \
              | head -1)
    fi
    if ! ${get_exe} "${url}"; then
        pythonize::die "Failed to download ${__ana_type} installer"
    fi
    pythonize::say -a 1 -b 1 "\nLaunching ${ana_type} installer.\n "
    chmod +x "${exe}"
    # Run the Anaconda/Miniconda installer in noninteractive (batch) mode.
    ./${exe} -b
    rm -f -- "${exe}"
    # Put our newly installed conda utility in PATH so we can use it throughout
    # the rest of this program at need. Note: This will only affect the current
    # process's and its child process's shell environments, not the calling
    # shell.
    export PATH="${__ana_dir}/bin:${PATH}"
    # Create a new conda environment containing the needed Python version if
    # we're not installing the latest Python 2.x or 3.x (see comments in
    # pythonize::main()).
    if [[ ${downgrade} ]]; then
        pythonize::create_conda_environment "python${py_vers}"
    fi
    if ! which conda &>/dev/null; then
        pythonize::die "Unable to find conda after installation."
    fi
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Install additional Python packages then update all packages.
# Globals:   Terminal-movement/terminal-color constants
# Free vars: main():
#                downgrade
#                opt_mini
#                opt_wrap
#                packages
#                py_vers
# Arguments: None.
# Functions: pythonize::die
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::install_python_packages() {
    local -a missing
    local p
    # Pip will _usually_ be installed at this point, but there's a chance it
    # may be absent. Let's make double-plus sure we have it.
    which pip &>/dev/null || conda install -y pip
    for p in "${packages[@]}"; do
        conda install -y "$p" && continue
        # If the package isn't in conda's default channels, try pip.
        pythonize::say -a 1 -b 1 \
            "\nAnaconda does not appear to have Python package \"$p\"" \
            "in its default repositories --- trying pip instead.\n "
        yes y | pip install "$p"
        (($?)) || continue
        # Pip's error status can't be trusted: When it encounters an exception
        # trying to install a package, it will sometimes find an alternate way
        # to install it --- but still return a nonzero status. So let's double
        # check existence of packages before we report failure.
        python -c "import ${p}" &>/dev/null && continue
        # In wrapper mode, assume every package argument is a hard dependency,
        # so exit with an error on the first package we can't
        # install unattended. Otherwise, report what we couldn't install and
        # leave it to the user to get the package some other way.
        if [[ ${opt_wrap} ]]; then
            pythonize::die "Unable to install required Python package" \
                           "\"${p}\" using conda or pip."
        fi
        pythonize::say -a 1 -b 1 \
            "\nUnable to install Python package \"${p}\" using" \
            "conda or pip. Continuing without it.\n "
        missing+=($p)
    done
    # Note: When the standard shell-wrapper template invokes pythonize in
    # wrapper mode, it always specifies Miniconda rather than Anaconda.
    if [[ ! ${opt_mini} ]]; then
        pythonize::say -a 1 -b 1 \
            "\nUpdating 100+ Python packages --- this will take some time.\n" \
            "\nTo reduce installation runtime as well as disk utilization," \
            "in the future you can install ${BOLD}miniconda${RESET}${GREEN}" \
            "instead. Miniconda contains only Python, the conda package" \
            "manager, and pip; you can then use conda to install just the" \
            "packages you currently need.\n "
    fi
    # Ideally, we'd always run conda --update to get all packages to their most
    # recent versions; however, that also replaces the environment's Python
    # with the latest release, which is explicitly not what we want.
    #
    # There's not a simple, clean way around that of which I'm aware, so we use
    # this kludge: Downgrade the Python version then fix any resulting package
    # mismatches by explicitly downgrading them to that Python version as well.
    if [[ ${downgrade} ]]; then
        conda install -y python=${py_vers}
        conda update -y "${packages[@]}"
    else
        conda update -y --all
    fi
    # The binstar package (extends packages available to install with conda by
    # allowing search of binstar repositories) is deprecated, so ensure that we
    # have anaconda-client instead if we're not using Miniconda.
    [[ ${opt_mini} ]] || conda install -y anaconda-client
    pythonize::say -b 2 "\nAnaconda Python has been successfully installed.\n "
    if ((${#missing[@]})); then
        pythonize::say "The following Python packages could not be installed" \
                       "using either conda or pip: ${missing[@]}"
    fi
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Run pythonize in permanent-installation mode (i.e., pythonize is
#            invoked without the --wrapper option).
# Globals:   PROG
#            Terminal-movement/terminal-color constants
# Free vars: main():
#                ana_dir
# Arguments: None.
# Functions: pythonize::confirm
#            pythonize::die
#            pythonize::install_anaconda
#            pythonize::install_python_packages
#            pythonize::say
#            pythonize::write_shell_startup
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::run_normal_mode() {
    local d
    # If conda is in PATH but its directory is not the one we are using for
    # this installation, let the user know that he has an existing Anaconda
    # installation and confirm he wants to create another.
    if which conda &>/dev/null; then
        d=$(which conda | awk -F '\/envs|\/bin' '{print $1}' 2>/dev/null)
        if [[ ${ana_dir} != ${d} ]]; then
            pythonize::say -n \
                "Anaconda appears to already be installed at this location:" \
                "\n\n\t${BOLD}${d}${RESET}\n" \
                "\nSince we are installing in a different directory, we do" \
                "not need to overwrite it.\n\nContinue installing a" \
                "new Anaconda? (y/n) "
            if ! pythonize::confirm; then
                pythonize::say -a 1 -b 1 "\nAborting at user request\n "
                return
            fi
        fi
    fi
    # If our target installation directory already exists, ask the user if we
    # can remove that directory and install a new Anaconda.
    if [[ -d ${ana_dir} ]]; then
        pythonize::say -n "Anaconda appears to already be installed at this" \
                          "location:\n\n\t${BOLD}${ana_dir}${RESET}\n" \
                          "\nIf you choose to continue, ${PROG} will" \
                          "remove this directory along with any conda" \
                          "environments and settings within." \
                          "\n\nContinue? (y/n) "
        if ! pythonize::confirm; then
            pythonize::say -a 1 -b 1 "\nAborting at user request\n "
            return
        fi
        if ! rm -rf -- "${ana_dir}"; then
            pythonize::die "Unable to remove ${ana_dir}"
        fi
        echo
    fi
    # In normal mode, we make a permanent installation: We install Anaconda
    # Python in either conda environment "root" or, if downgrading, conda
    # environment "python<version-number> (see comments in pythonize::main()).
    # We also modify the user's shell startup via such that Anaconda Python
    # replaces the system Python for that user.
    pythonize::install_anaconda
    pythonize::write_shell_startup
    pythonize::install_python_packages
    pythonize::say -a 1 \
        "Start a fresh shell session to begin using your new Python" \
        "installation, or run this command:" \
        "\n\n\t${BOLD}${WHITE}source ~/.pythonize.startup\n "
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Run pythonize in wrapper mode (i.e., pythonize is invoked with the
#            --wrapper option).
# Globals:   None.
# Free vars: main():
#                ana_dir
#                wrapper
# Arguments: None.
# Functions: pythonize::create_conda_environment
#            pythonize::install_anaconda
#            pythonize::install_python_packages
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::run_wrapper_mode() {
    local c_env
    local d
    # If the user has a functioning Anaconda Python available, find it and use
    # conda to set up a conda environment named "pythonized_<program-name>" to
    # be used by the wrapped Python program.
    if ! which conda &>/dev/null; then
        for d in ~/{ana,mini}conda{,3}/bin; do
            [[ -d $d ]] || continue
            source "${d}/activate" 2>/dev/null && break
        done
    fi
    if which conda &>/dev/null; then
        pythonize::create_conda_environment "pythonized_${wrapper}"
        pythonize::install_python_packages
    else
        # If we can't find an existing Anaconda Python, install it; however,
        # unlike normal mode, do not modify the user's shell startup to replace
        # the system Python with Anaconda. We'll use it for the wrapped Python
        # program without making permanent shell environment changes --- but
        # we'll leave that Python on disk so we can use it again later and/or
        # so the user can manually add it to his startup if he likes.
        [[ -d ${ana_dir} ]] && rm -rf -- "${ana_dir}"
        pythonize::install_anaconda
        pythonize::install_python_packages
    fi
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Print formatted general messages.
# Globals:   Terminal-movement/terminal-color constants.
# Arguments: Message string.
# Options:   -a N   Print N trailing newlines.
#            -b N   Print N leading newlines.
#            -n     End without a newline --- next text will be on same line.
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::say() {
    # The comments from pythonize::die() apply to this function as well. The
    # formatting here is a bit different --- we chop up the lines and append
    # " >   " to the beginning of each while ensuring all lines remain less
    # than 79 characters in length --- but the general mechanism remains the
    # same.
    local i
    local nl_after
    local nl_before
    local no_final_nl
    # Parse formatting options.
    while (($# > 0)); do
        case $1 in
            -n)
                no_final_nl=true
                shift
                ;;
            -@(a|b))
                [[ $2 =~ ^[0-9]+$ ]] || continue
                for ((i=0; i < $2 && $2 >= 0; i++)); do
                    case $1 in
                        -a) nl_after+=$'\n'  ;;
                        -b) nl_before+=$'\n' ;;
                    esac
                done
                shift 2
                ;;
            *) break ;;
        esac
    done
    local msg=$(fold -s -w 72 <(echo -e "$@"))
    local line_ct=$(wc -l <(echo "${msg}") | awk '{print $1}')
    local filler
    for ((i=0; i < line_ct && line_ct >= 0; i++)); do
        filler+="${RESET}${WHITE} >  ${GREEN}\n"
    done
    filler=${filler%\\n}
    msg=$(paste -d ' ' <(echo -e "${filler}") <(echo "${msg}"))
    if [[ ${no_final_nl} ]]; then
        echo -n "${nl_before}${msg}${RESET}"
    else
        echo "${nl_before}${msg}${nl_after}${RESET}"
    fi
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Display man page for pythonize.
# Globals:   INLINE_MAN_PAGE
# Arguments: None.
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::show_help() {
    # Writing to the traditional man page location /usr/share/man, or even to
    # a directory in /usr/local, usually requires a privileged user. So that
    # unprivileged users can install and use pythonize, we store its man page
    # source in a global variable. We write the source to a temp file in
    # the user's home directory when this function is called then invoke man to
    # render it.
    mkdir -p ~/tmp
    local manpage=~/tmp/pythonize.manpage.1
    cat <<<"${INLINE_MAN_PAGE}" > "${manpage}"
    if [[ ! -f ${manpage} ]]; then
        pythonize::die "Unable to find man page at ${manpage}"
    fi
    # Note: The exec call overwrites the running program with a new process, so
    # if you subclass this (see comments in "BEGIN EXECUTION" below), keep that
    # in mind: This function will terminate the current shell, regardless of
    # what comes after.
    exec man "${manpage}"
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions:   Modify shell startup to use Anaconda rather than system Python.
# Globals:   STARTUP
# Arguments: None.
# Returns:   None.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pythonize::write_shell_startup() {
    # Matching and substituting strings in a file of unknown composition is a
    # highly error-prone process using shell. To avoid that, we create our own
    # startup file -- ~/.pythonize.startup -- and recreate it whenever
    # pythonize runs in normal mode; that way, we guarantee our startup file is
    # always in a predicatable state.
    #
    # We append a line sourcing ~/.pythonize.startup to the end of the user's
    # normal shell startup and handle the logic of figuring out which Python
    # environment to bootstrap there rather than in a startup file that the
    # user is likely to edit.
    local line=$(echo -e \
        "\n# Added by pythonize" \
        "\n[[ -f ~/.pythonize.startup ]] && source ~/.pythonize.startup\n ")
    local startup=~/.pythonize.startup
    local path=$(dirname "$(which conda)")
    # We replace the string "__REPLACE__" in $STARTUP with the current parent
    # directory of conda; this should be the Python environment we want to use.
    sed 's,__REPLACE__,'"${path}"',g' <(echo "${STARTUP}") > "${startup}"
    # Add $line to the first shell startup file that's writable.
    for f in ~/.bash_profile ~/.bashrc ~/.bash_profile ~/.bash_login \
             ~/.profile
    do
        if [[ -w $f ]]; then
            # If the shell startup file already has $line, don't add it.
            #
            # The unusual syntax of the following statement is purely to avoid
            # a 126-character line. I can't defend it --- but _every_ other
            # line was under 79 characters, so I couldn't help myself. (This
            # is, after all, a personal project for fun, so I'm not wasting any
            # company's time.  ^.^ )
            if awk -f <(
                    echo -n '/^[#] Added by pythonize/ {getline; if (!/^[#]/' \
                            '&& /\/\.pythonize\.startup/) matched=1} END {if' \
                            '(!matched) exit 1}'
                    ) "$f"
            then
                break
            fi
            echo -n "${line}" >> "$f" && break
        fi
    done
}



# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Man page.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

INLINE_MAN_PAGE=$(cat <<EOF_MAN_PAGE
.\"
.\" MAN PAGE COMMENTS to
.\"
.\" Prince Williams
.\" prince@princebot.com
.\" https://github.com/princebot/pythonize
.\"
.\" Last Change: Thu Oct 1 2015
.\"
.mso www.tmac
.TH PYTHONIZE 1 "2015-10-01" "github.com/princebot/pythonize" \
    "User Commands"
.SH NAME
pythonize \- download, install, and configure Python in one line
.SH SYNOPSIS
.ad l
.nh
.TP 10
.B pythonize
.RB [ --python-version
.IR PYTHON-VERSION ]
.RB [ --miniconda ]
.br
.RB [ --packages
.IR PYTHON-PACKAGE " [" PYTHON-PACKAGE ...]]
.br
.RB [ --wrapper
.IR APPLICATION-NAME ]
.SH DESCRIPTION
.ad n
.hy 14
.B pythonize
performs unattended download, installation, and configuration for the
.B Anaconda Python distribution
and its environment / package manager
.BR conda .
In
one command line, you get a ready-to-use Python preloaded with the libraries
you want.
.P
When invoked without options,
.B pythonize
does this:
.sp
.RS 4
.PD 0
.TP 3
\[->]
downloads the latest Anaconda release,
.TP
\[->]
installs Anaconda noninteractively using sane defaults,
.TP
\[->]
uses
.I conda
to update Python packages, and
.TP
\[->]
adds Anaconda to
.I PATH
in your shell startup.
.RE
.PD
.P
Anaconda Python provides 100+ popular Python packages in addition to the
standard library. For a leaner installation (10x smaller) including only
Python and
.IR conda ,
.B pythonize
supports installing
.B Miniconda
instead by using the
.B --miniconda
option (see
.B OPTIONS
below).
.P
.B pythonize
also provides a method for wrapping Python programs: Invoked
with the
.B --wrapper
option,
.B pythonize
abstracts Python version and library dependencies from the wrapped
application\[cq]s users, automatically ensuring the execution environment
satisfies your requirements.
.P
Using
.B pythonize
in wrapper mode eliminates any need to consider your users\[cq] Python skill
level, their ability to find and install Python packages, their current
Python version\[em]or whether they have Python installed at all.
.P
How wrapping works:
.sp
.RS 4
.ad l
.nr step 1 1
.TP 3
\n[step]
In place of your actual Python program, make your application\[cq]s main executable
a copy of the shell wrapper included with
.BR pythonize ,
renamed as your application.
.TP 3
\n+[step]
Move your Python program to
.IR .runtime/<application-name>.py
in your application package\[cq]s directory.
.TP 3
\n+[step]
User runs your application\[cq]s main executable.
.TP 3
\n+[step]
Shell wrapper checks all currently installed Pythons against your dependencies,
calling
.B pythonize
to fetch anything needed.
.TP 3
\n+[step]
Shell wrapper then runs your Python program.
.RE
.PD
.ad n
.P
For more on wrapper functionality, see
.BR "OPTIONS " and " WRAPPER MODE "
below.
.SH OPTIONS
.TP 7
.BR -h ", " --help
Display this manual page.
.TP
.BR -m ", " --miniconda
Install the more lightweight
.B Miniconda
(10x smaller) rather than Anaconda. Miniconda includes only Python and
.IR conda ;
you can then use conda to install additional Python packages.
.TP
.BR -p ", " --packages " [" \fIpackage " [" \fIpackage ...]]
Install these additional Python packages. For example,
.RS +11
.P
.B pythonize --packages httpie nose requests
.RE
.TP
.BR -v ", " --python-version " \fIversion"
Install Python
.I version
rather than 2.7 into the default Anaconda environment. If the
.I version
argument is 2 or 3 without specifying a minor version number,
.B pythonize
downloads the latest 2.x or 3.x respectively.
.TP
.BR -w ", " --wrapper " \fIapplication-name"
Run
.B pythonize
in wrapper mode, using
.I application-name
as a suffix for the
.I conda
environment we\[cq]ll create if we need to make a new one.
.sp
Rather than invoking wrapper mode directly, it\[cq]s recommended in most cases to use the shell wrapper included with the
.B pythonize
package, which handles this and other wrapper implementation
details for you.
.SH NORMAL MODE
In normal mode (that is, when invoked without the
.B --wrapper
option),
.B pythonize
installs either Anaconda or Miniconda for the current user through this
sequence of actions:
.sp
.RS 4
.ad l
.nr step 1 1
.TP 3
\n[step]
Check if Anaconda is installed. If it is and it occupies our target
installation directory, prompt to overwrite.
.TP 3
\n+[step]
Download latest Anaconda release.
.TP 3
\n+[step]
Run the Anaconda installer in noninteractive mode.
.TP 3
\n+[step]
Install any additional Python packages specified with the
.B --packages
option (see
.B OPTIONS
above).
.TP 3
\n+[step]
Modify user\[cq]s shell startup to set Anaconda Python rather than the system Python as the user\[cq]s default.
.RE
.P
.ad n
When
.B pythonize
succesfully completes, begin using Anaconda by starting a new shell or running
this command in the current shell:
.RS 7
.P
.B source ~/.pythonize.startup
.RE
.SH WRAPPER MODE
.SS Invocation
In wrapper mode (that is, when invoked with the
.B --wrapper
option),
.B pythonize
installs a Miniconda environment intended to be used by the wrapped Python
application. This differs from normal mode as follows:
.sp
.ad l
.RS 4
.TP 3
\[->]
Shell startup files are not modified.
.TP
\[->]
If Anaconda is already installed,
.B pythonize
uses an existing
.I conda
to satisfy Python dependencies instead of creating a fresh Anaconda
installation.
.TP
\[->]
If we need to install Anaconda Python, we fetch Miniconda instead of Anaconda,
regardless of contrary explicit arguments.
.TP
\[->]
If any packages specified with the
.B --packages
option (see
.B OPTIONS
above) cannot be installed,
.B pythonize
halts with an error rather than just issuing a warning.
.RE
.ad n
.P
The complete sequence of actions undertaken in wrapper mode follows:
.sp
.RS 4
.ad l
.nr step 1 1
.TP 3
\n[step]
Search for any existing Anaconda or Miniconda installations.
.TP 3
\n+[step]
If we find an existing
.I conda
utility, use it to create a
conda environment named
.B pythonized_<application-name>
.TP 3
\n+[step]
If we can\[cq]t find a
.I conda
to use, install Miniconda and use its root (default) conda environment.
.TP 3
\n+[step]
Use
.I conda
to install the specified Python version and libraries.
.RE
.P
.ad n
When
.B pythonize
successfully completes, you\[cq]ll have a Python environment suitable for the
wrapped Python application.
.SS Packaging Python applications
To make wrapping arbitrary Python programs with
.B pythonize
easy, the
.B pythonize
utility contains an
.B example_package directory
providing the required files in the recommended file layout for your
application (see
.B FILES
below).
.P
To get started, follow these steps:
.sp
.RS 4
.ad l
.nr step 1 1
.TP 3
\n[step]
Copy the
.B example_package directory
and rename it for your application. (Note: For the remainder of this section,
all pathnames will be relative to this directory.)
.TP 3
\n+[step]
Rename the shell wrapper at
.I example
to the name you\[cq]d like for your main executable (for example,
.IR nmapcli ).
.TP 3
\n+[step]
Replace
.I \%.runtime/example.py
with your Python program.
.TP 3
\n+[step]
Set your Python program\[cq]s filename to match your main executable, but add a
.I .py
extension (for example,
.IR nmapcli.py ).
.TP 3
\n+[step]
Edit the four variables in
.I \%.runtime/wrapper.env
with settings specific to your application (the shell wrapper sources this file
during execution).
.sp
By default,
.I \%.runtime/wrapper.env
sets the following:
.RS 7
.TP 13
.B PROG
Name the shell wrapper displays in console messages before executing your
Python application (by default, the shell wrapper\[cq]s filename).
.TP
.B WRAPPED_PROG
Filepath to your main Python program (by default,
.IR \%.runtime/<application>.py ).
.TP
.B PY_VERSION
The Python version your application requires (by default, the most recent
Python 3.x).
.TP
.B PY_PACKAGES
List of packages outside the Python standard library that your application
requires (by default, colorama and requests).
.RE
.sp
.in +3
You can also set environment variables for your Python program in
.I \%.runtime/wrapper.env
(for example,
.IR export\[ul]PYTHONPATH=<path> ).
.in -3
.RE
.P
.ad n
You\[cq]re done: The Python application is now wrapped with
.BR pythonize .
.P
Users will run your application the same way they did before. Instead of a
Python program, however, your application\[cq]s main executable is now a shell
wrapper that does the following:
.sp
.RS 4
.ad l
.nr step 1 1
.TP 3
\n[step]
Check if the system Python meets the Python verison and library requirements
listed in
.I \%.runtime/wrapper.env.
If it does,
.I exec
the Python application\[em]and we\[cq]re done.
.TP 3
\n+[step]
If the system Python cannot satisfy the dependencies, try each installed
Anaconda Python environment.
.TP 3
\n+[step]
If none of the currently installed Anaconda Python environments can satisfy
the dependencies, run
.B pythonize
in wrapper mode to fetch the Python version and/or libraries we still need.
.TP 3
\n+[step]
With our dependencies met,
.I exec
the Python application.
.RE
.P
.ad n
This is the standard way to wrap a Python application using
.BR pythonize ,
but you can customize this process by editing the source files, which are
extensively commented for that purpose.
.P
Alternatively, because of the style in which
.B pythonize
is written, you can source (import)
.B pythonize
as a shell library then use it in a manner similar to OOP classes: You can then
call its functions as psuedo-methods or subclass
.BR pythonize ,
customizing its functions as you like.
.P
If customizing
.B pythonize
in this way interests you, consult the source code comments for implementation
and usage details.
.SH ENVIRONMENT
.TP 7
.I PATH
Used during runtime to find the system Python or a currently active Anaconda
Python environment.
.sp
In normal mode,
.B pythonize
modifies
.I PATH
in shell startup files to set Anaconda Python rather than the system
Python as the user\[cq]s default (see
.B NORMAL MODE
above).
.sp
In all modes,
.B pythonize
modifies
.I PATH
during runtime as it looks in every standard installation location to find an
existing Anaconda Python before selecting one for its use. This affects the
running
.B pythonize
process, its child processes, and any wrapped Python program\[em]but not the
parent shell.
.P
While by default
.I \%<package-directory>/.runtime/wrapper.env
sets no environment variables, as a customization you can use this file to
export environment variables affecting a wrapped Python application (see
.B WRAPPER MODE
above).
.SH FILES
.B ~/.bash_profile
.br
.B ~/.bashrc
.br
.B ~/.bash_login
.br
.B ~/.profile
.br
.RS 7
.B pythonize
appends a line sourcing
.I ~/.pythonize.startup
to the first listed shell startup file that\[cq]s
writable  when run in normal mode (see
.B NORMAL MODE
above).
.RE
.P
.B ~/anaconda
.br
.B ~/anaconda3
.br
.B ~/miniconda
.br
.B ~/miniconda3
.RS 7
.B pythonize
creates, removes, or alters files within these directories depending on what
Anaconda Python version is selected for installation (see
.BR OPTIONS " and " "NORMAL MODE"
above).
.RE
.TP
.B ~/tmp/pythonize.manpage.1
When invoked with the
.B --help
option,
.B pythonize
creates
.I ~/tmp
if it doesn\[cq]t exist then writes the groff source for this manual page to
.IR \%~/tmp/pythonize.manpage.1 ,
overwriting any preexisting file with that name.
.TP
.B <pythonize-directory>/example_package/example
Initial location of shell wrapper (see
.B WRAPPER MODE
above).
.TP
.B <pythonize-directory>/example_package/.runtime/example.py
Initial location of Python application to wrap in wrapper mode; by default,
this contains a demo Python script (see
.B WRAPPER MODE
above.)
.TP
.B <pythonize-directory>/example_package/.runtime/pythonize
Hard link to
.BR pythonize :
.I <pythonize-directory>/pythonize
.TP
.B <pythonize-directory>/example_package/.runtime/wrapper.env
Initial location of settings file for wrapped Python applications (see
.B WRAPPER MODE
above).
.SH EXAMPLES
Default installation (installs Python 2.7,
.IR conda ,
.IR pip ,
and 100+ popular Python packages using Anaconda):
.P
.RS +7
.B pythonize
.RE
.P
Install latest version of Python 3:
.P
.RS +7
.B pythonize --python-version 3
.RE
.P
Install a specific Python 3 release, then add the httpie, nose, and requests
libraries into the default environment post-installation.
.P
.RS +7
.B pythonize --python-version 3.3 --packages httpie nose requests
.RE
.SH SEE ALSO
.PD 0
.TP 17
.B Anaconda Python
.URL https://store.continuum.io/cshop/anaconda
.TP
.B conda
.URL http://conda.pydata.org/docs
.TP
.B pip
.URL https://pip.readthedocs.org/en/stable/
.TP
.B pythonize
.URL http://github.com/princebot/pythonize
.PD
EOF_MAN_PAGE
)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# ~/.pythonize.startup contents
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

declare -r STARTUP=$(cat <<'EOF_PYTHONIZE_STARTUP'
#!/usr/bin/env bash
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Name:     pythonize.startup
# Source:   https://github.com/princebot/pythonize
# Author:   prince@princebot.com
# Synopsis: Sourced at beginning of shell session to load Anaconda Python.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# pythonize appends a line sourcing this to the end of an existing shell
# startup script, e.g., ~/.bash_profile.

if [[ -d __REPLACE__ ]]; then
    __dir="__REPLACE__"
    # Append Anaconda Python to PATH if not already present. This works exactly
    # like pathmunge() from most Linuxes' /etc/profile.
    if [[ ! ${PATH} =~ (^|:)"${__dir}"($|:) ]]; then
        PATH="${__dir}:${PATH}"
    fi
    export PATH
    # Conda adds the name of the current conda environment to the prompt
    # unless you're using the root environment, so let's temporarily disable
    # that behavior before switching to our target environment if we're using
    # something other than root.
    if [[ ${__dir} =~ .*(ana|mini)conda/envs ]]; then
        __env=$(echo -n "${__dir}" | awk -F '/' '{printf $(NF - 1)}')
        conda config --set changeps1 false
        source activate "${__env}"
        conda config --set changeps1 true
    fi
fi 2>/dev/null

unset -v __dir
unset -v __env
 
EOF_PYTHONIZE_STARTUP
)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Begin execution.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# When this program is run directly (i.e., invoked with ./<file> or bash
# <file>), $0 is the same filename as $BASH_SOURCE. However, when this program
# is sourced (i.e., invoked with . <file> or source <file>), $0 is the calling
# program, but $BASH_SOURCE is the _current_ program.
#
# Because of that (probably unintended) Bash behavior, the below line has this
# effect: If we're in a direct invokation, run pythonize; otherwise, set its
# globals as environment variables affecting the calling shell and export the
# defined functions. This is functionally similar to a common Python idiom:
#
#        if __name__ == '__main__'
#            main()
#
# I've written pythonize this way so it can be more easily extended: You can
# import it into other shell programs like an object-oriented class and use its
# functions like methods --- or even subclass it by importing this, overriding
# methods with custom behavior as you like, then calling pythonise::main() (or
# <subclass>::main()).

if [[ $(basename "$0") == $(basename "${BASH_SOURCE}") ]]; then
    pythonize::main "$@"
else
    for __method in $(declare -F | awk '$3 ~ /^pythonize::/ {print $3}'); do
        export -f "${__method}"
    done
fi
    
